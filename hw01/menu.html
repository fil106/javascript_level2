<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Menu</title>
    <script>
    	var COUNT = 1;

        // Описываем базовый класс
        function Container() {

        	/* Параметры */
            this.id = '';
            this.className = '';
            this.htmlCode = '';

        }

        //метод в классе Container для фиг пойми чего
        Container.prototype.render = function () {

            return this.htmlCode; //возвращаем параметр htmlCode

        };

        // Описываем класс меню
        function Menu(my_id, my_class, my_items) {

            Container.call(this);  //Этой записью мы наследуемся от нашего базового класса

            /* Параметры */
            this.id = my_id;
            this.className = my_class;
            this.items = my_items;
            this.deleteButton = '<button onclick="remove(' + this.id + ')">Удалить меню</button>';

        }

        Menu.prototype = Object.create(Container.prototype); //передаем в класс 'Menu' прототип класса 'Container'
        Menu.prototype.constructor = Menu; //Если не сделать такую запись, то при создании экземпляра класса, будет использоваться родительский конструктор.

        //метод в классе Menu для отрисовки меню
        Menu.prototype.render = function () {

            var result = '<ul class="' + this.className + '" id="' + this.id + '">';
            this.items.forEach(function (item) {
                result += item.render();
            });

            // Также можно использовать и другую конструкцию, например на случай
            // с объектами.
            //
            // for (var i = 0; i < this.items.length; i++) {
            //     if(this.items[i] instanceof MenuItem){
            //         result += this.items[i].render();
            //     }
            // }
            //
            // Результат будет одинаковый

			result += this.deleteButton;
            result += '</ul>';
            return result;

        };

        // Описываем класс пунктов меню
        function MenuItem(my_href, my_name) {

            Container.call(this); //Этой записью мы наследуемся от нашего базового класса

            this.href = my_href;
            this.name = my_name;

        }

        MenuItem.prototype = Object.create(Container.prototype);
        MenuItem.prototype.constructor = MenuItem;

        MenuItem.prototype.render = function () {
            return '<li><a href="' + this.href + '">' + this.name + '</a></li>';
            // Здесь по ошибке у <li> был прописан клас, который мы собственно не
            // определяли.
        };

        //******Варианты вывода нашего меню*******
        // Вариант №1
		function createMenu() {

	    	Container.call(this);

	    	var menu_1 = new MenuItem('/', 'Главная');
	        var menu_2 = new MenuItem('/catalogue/', 'Каталог');
	        var menu_3 = new MenuItem('/contacts/', 'Контакты');
	        var menu_items = [menu_1, menu_2, menu_3];
	        var menu = new Menu('my_id_' + COUNT++, 'my_class', menu_items);

	        document.getElementById('menu').innerHTML += menu.render();

	    }

	    function remove(id) {
	    	document.getElementById('menu').removeChild(id);
	    }


        // Вариант №2 - более изящный
        // window.onload = function () {
        //     var menuBlock = document.getElementById('menu');
        //     var menu = new Menu('my_menu', 'my_class', [
        //         new MenuItem('/', 'Главная'),
        //         new MenuItem('/catalogue/', 'Каталог'),
        //         new MenuItem('/contacts/', 'Контакты')
        //     ]);
        //     menuBlock.innerHTML = menu.render();
        // }

        // window.onload - этим мы говорим браузеру, что сначала надо загрузить html
        // разметку а после уже исполнить наш код. Чтобы не прибегать к этой конструкции,
        // можно тэг <script> поставить перед закрывающим </body>



    </script>
</head>
<body>
    <div id="menu">
    	<button onclick="createMenu()">Добавить меню</button>
    </div>
</body>
</html>